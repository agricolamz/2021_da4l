---
editor_options: 
  chunk_output_type: console
---

# Эмпирическая байесовская оценка

```{r setup07, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
theme_set(theme_bw())
```

```{r}
library(tidyverse)
```


Метод жмпирической байесовской оценки (Empirical Bayes estimation) --- один из байесовских методов, в рамках которого:

* производят оценку априорного распределения вероятностей на основании имеющихся данных
* используют полученное априорное распределение для получение апостериорной оценки для каждого наблюдения

Рассмотрим пример данных из статьи [@daniel19], в которой аннализировались интервью с людьми из деревени Махалёвская и анализировали ряд консервативных и инновативных  черт в их речи.

```{r}
mikhalevskaja <- read_csv("https://raw.githubusercontent.com/agricolamz/2021_da4l/master/data/ustya_data.csv")
glimpse(mikhalevskaja)
```

Представим себе, что мы решили задаться целью найти наиболее диалектных носителей:

```{r, fig.height= 9, fig.width=11}
library(tidytext)
mikhalevskaja %>% 
  mutate(ratio = conservative/total,
         speaker = reorder_within(speaker, ratio, feature)) %>% 
  ggplot(aes(ratio, speaker, color = gender))+
  geom_point()+
  facet_wrap(~feature, scales = "free")+
  scale_y_reordered()
```

Не очень легко это анализировать... Давайте выберем один признак -- подъем a: консервативными считались формы [ꞌpʲetʲero], а инновативной -- реализация [ꞌpʲatʲərə]. Посчитаем долю и отсортируем:

```{r}
mikhalevskaja %>% 
  filter(feature == "a-e") %>% 
  mutate(ratio = conservative/total) %>% 
  arrange(desc(ratio)) %>% View()
```

В целом, всего в интервью встречается от 1 до 73 контекстов для реализации признака. Хотим ли мы верить, что avt1928 с одним наблюдением диалектнее, чем egp1928 с 39 наблюдениями, только на основании доли?

```{r}
mikhalevskaja %>% 
  filter(feature  == "a-e") %>% 
  mutate(ratio = conservative/total) %>% 
  ggplot(aes(ratio))+
  geom_histogram()
```

Мы можем провести байесовский апдейт, но для этого нам нужно априорное распределение. Трюк, который предлогает байесовская эмпирическая оценка заключается в том, что априорное распределение можно попробовать получить на основании данных:

```{r}
library(fitdistrplus)
mikhalevskaja %>% 
  filter(feature == "a-e") %>% 
  mutate(ratio = conservative/total) %>% 
  filter(ratio != 0, # оказывается fitdist плохо работает, когда много крайних точек
         ratio != 1) ->
  for_beta_estimation 
  
beta_est <- fitdist(for_beta_estimation$ratio, distr = 'beta', method = 'mle')
beta_est
```

Сделаем байесовский апдейт:

```{r}
mikhalevskaja %>% 
  filter(feature == "a-e") %>% 
  mutate(alpha_prior = beta_est$estimate[1],
         beta_prior = beta_est$estimate[1],
         alpha_post = conservative+alpha_prior,
         beta_post  = innovatuve+beta_prior,
         mean_post = alpha_post/(alpha_post+beta_post),
         ratio = conservative/total) %>% 
  ggplot(aes(ratio, mean_post, label = speaker, color = total))+
  geom_abline(intercept = 0, slope = 1, linetype = 2)+
  geom_point()+
  ggrepel::geom_text_repel()+
  coord_fixed()
```

Как видно байесовская оценка не сильно отличается от старой оценки средним, однако таким образом мы можем видеть, что значительно отличаются наблюдения, от которых у нас мало данных.

```{r}
mikhalevskaja %>% 
  filter(feature == "a-e") %>% 
  mutate(alpha_prior = beta_est$estimate[1]*5,
         beta_prior = beta_est$estimate[1]*5,
         alpha_post = conservative+alpha_prior,
         beta_post  = innovatuve+beta_prior,
         mean_post = alpha_post/(alpha_post+beta_post),
         ratio = conservative/total) %>% 
  ggplot(aes(ratio, mean_post, label = speaker, color = total))+
  geom_abline(intercept = 0, slope = 1, linetype = 2)+
  geom_point()+
  ggrepel::geom_text_repel()+
  coord_fixed()
```


```{r}
mikhalevskaja %>% 
  group_by(speaker) %>% 
  summarise(conservative = sum(conservative), 
            innovatuve = sum(innovatuve))
  mutate(ratio = conservative/total) %>% 
  filter(ratio != 0, # оказывается fitdist плохо работает, когда много крайних точек
         ratio != 1) ->
  for_beta_estimation 
  
beta_est <- fitdist(for_beta_estimation$ratio, distr = 'beta', method = 'mle')
beta_est

```

